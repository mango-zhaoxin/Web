# 1.使用 ES6 之前的模块加载器

## 1.1 CommonJS

CommonJS 是同步声明依赖的模块规范，这个规范主要用于服务器端实现模块化代码组织，但是也可以用于定义浏览器中使用的模块定义.

CommonJS 模块语法不能在浏览器中直接运行.

CommonJS 以服务端为目标环境，能够一次性把所有模块都加载到内存.

在 CommonJS 中，模块加载时模块系统时执行是同步操作，由于是在后端使用的，读取文件非常的快，所以不存在阻塞的问题，但是浏览器是单线程的，一次只能去做一件事情，不能同时去加载所有的资源，所以会遇到阻塞的问题，因此 CommonJS 语法不能直接在浏览器里面去运行

CommonJS 模块定义需要使用 require() 来指定依赖，而使用 module.exports 对象定义自己的公共 API, 可以在里面导出变量、方法或者类.

```js
// match.js
var basicNum = 0;
function add(a, b) {
  return a + b;
}

module.exports = {
  basicNum: basicNum,
  add: add,
}

// 这样的写法也是可以滴，实验过了
// 定义一个对象，module.exports 去导出这个对象
var basicNum = 0;
function add(a, b) {
  return a + b;
}

var returnObj = {
  add: add,
  basicNum: basicNum
}

module.exports = returnObj;
```

```js
// test.js 
var math = require('./math')
var result = math.add(2, 5)

console.log(result) // 5
```

执行 node test.js, 得到结果5

通过上面的这个简单的例子，我们可以看到，在match.js 里面定义的 basicNum 和 add 方法，挂载到了一个对象上面，通过 module.exports 导出这个对象，然后再其他的文件里面，通过 require的方法，去引入这个文件，进而可以读取到挂载在 module.exports 对象上面的属性和方法。

```js
var moduleA = require("./moduleA");

module.exports = {
  age: 18,
  getAge: function () {
    console.log(age);
  },
};
```

```js
var http = require("http");
var PORT = 8000;

http.createServer(function (req, res) {
  res.end('hello world');
}).listen(PORT);

console.log('listen to ' + PORT);
```

## 1.2 AMD

异步模块定义（AMD）的模块定义以浏览器为目标执行环境

AMD 加载器会在所有依赖模块加载完毕之后去调用

## 1.3 通用模块定义规范（UMD）

UMD: Umiversal Module Definition

UMD 定义的模块会在启动的时候，检测要使用那个模块系统，然后进行适当的配置，并把所有逻辑包装在一个立即调用的函数表达式中。

# 2.使用 ES6 模块

## 前端模块化

### 模块化的历史

> 1. 什么是模块？

- 先来思考一个问题，写代码的本质是什么？

我认为，写代码的本质，归结到底就是管理变量，不管是页面、组件、模块，还是更小单元的方法、变量，其实说到底，最终处理的都是变量，把变量进行正确的管理。

那么问题来了，管理变量的方式方法都有哪一些呢？

在 JS 的早期，变量命名冲突，全局变量污染是我们经常会遇到的问题，为了解决这个问题，我们可以想到以下的一些方法：

使用闭包，通过把变量塞到函数里面的方式，解决了函数的全局污染问题

但是，使用了闭包之后，问题又来了，变量是不污染了，但是函数之间的变量如何进行通信呢？

这个时候，我们就可以想到把变量挂载到全局的方法，比如挂着到 window 上面，这样一来，其他的函数，就可以通过从全局上面读取到这个变量了。

虽然这种方式可以解决函数之间变量通信的问题，但是等到代码量上去以后，这样的方式也变得难以维护，不能够解决。

为了比较好的解决这个问题，我么可以改造成接口的形式，函数里面 return 出来一个对象，我们把需要返回的内容放到这个对象上面进行返回。

说得更清楚一些，我们写一个函数，return 出来别人希望拿到的东西，比如，return 出来一个对象，这个对象上面有属性和方法，别的函数只需要去调用这个函数，就可以去调用这个接口了，就可以去使用这些数据了。

- 模块化的原理（本质、雏形）是什么？

把所有的东西都封装到一个函数里面，然后通过某个接口去暴露出我们想要暴露的接口，这就是现代化模块机制的基本雏形，或者是现代化模块机制本质上的原理。

总结：本质上模块就是一种提供对外通信接口，进行代码切分/组合的管理方式。其呈现的方式因不同的模块化方案而不同，基本是以文件粒度区分。

> 2. 为什么要用模块化？

随着前端的能力在纵深都得到了加强之后，迫切的需要更好的代码管理、组织、通信的模式，所以各种模块化的技术方案开始出现。

[1] 模块化可以把复杂问题分解为多个子问题。

- 关注分离（单一职责）

闭包是现代化模块化编程的基石

[2] 模块化是大型软件开发的技术基础

- 更优雅的进行代码管理
- 替换、复用、拓展
- 内聚（变量、行为内聚在模块内，对外暴露接口进行通信）

[3] 开发方式的革新

- 方便多人协同、面向过程开发

> 3. 模块化发展历史

### 模块化技术方案介绍

### 手写模块化实现
